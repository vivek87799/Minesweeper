# -*- coding: utf-8 -*-
"""minesweeper.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Tqilkmwrd5Cr03rTsbDEeEnFyId3LBDr

# Logical Implementaion
  #

# imports
"""

import itertools
from abc import ABC, abstractmethod
from typing import List, Dict, Tuple

"""# Field values that hold constant"""

inputs = "inputs"
no_rows = "no_rows"
no_cols = "no_cols"
no_bombs = "no_bombs"
bomb_positions = "bomb_positions" 
uncover_positions = "uncover_positions"
outputs = "output"

class Field:
  BOMB_VALUE = float('inf')
  NO_BOMB_VALUE = 0
  BOMB_STEPPED = 'X'
  COVERED_FIELD = '*'
  POSX = 0
  POSY = 1

"""# Game Interface"""

class IGame(ABC):
  @abstractmethod
  def add_bombs(row: int, col: int):
    """
    Add bombs to a specific coord row, col
    """
    pass

  @abstractmethod
  def update_board():
    """
    update the bomb count in each coord wrt. the bombs in neighbours
    """
    pass
    
  @abstractmethod
  def uncover(row: int, col: int):
    """
    Uncover the coord and check for bomb in neighbourhood 3x3 kernel 
    if no bomb found in neighbourhood then uncovers the neighbourhood
    """
    pass
  
  @abstractmethod
  def print_board():
    """
    prints the uncovered game board
    """
    pass

"""# Game Implementaion"""

class Game:
  def __init__(self, no_rows: int, no_cols: int, no_bombs:int):
    self.no_rows = no_rows
    self.no_cols = no_cols
    self.no_bombs = no_bombs
    self.bombs_uncovered = 0
    self.game_board = []
    self.game_board_uncovered = []
    self.kernel_size = 3
    # Create game boards
    for i in range(0, self.no_rows):
      board = []
      board_uncovered = []
      for j in range(0, self.no_cols):
        board.append(Field.NO_BOMB_VALUE)
        board_uncovered.append(Field.COVERED_FIELD)
      self.game_board.append(board)
      self.game_board_uncovered.append(board_uncovered)
  
  def add_bombs(self, row: int, col: int):
    """
    adding bombs to the board
    """
    self.game_board[row][col] = Field.BOMB_VALUE

  def update_bombs(self):
    """
    Updating the no. of bombs in the neighbourhood of each field
    """
    for row in range(0, self.no_rows):
      for col in range(0, self.no_cols):
        # function to get the no. of bombs in neighbourhood
        # self.game_board[row][col] = 
        # get kernel range
        kernel_range = self.get_kernel_range(row, col, kernel_size=3)
        self.count_bomb_in_neighbourhood(row, col, kernel_range)
  
  def print_board(self, game_board=None):
    """
    Print the game_board_uncovered
    """
    if game_board == None: 
      game_board = self.game_board_uncovered
    # print(*['*' for i in range(0, self.no_cols+2)])

    for row in range(0, self.no_rows):
      print(f'#', end=' ')
      for col in range(0, self.no_cols):
        print(f'{game_board[row][col]}', end=' ')
        
      print(f'# ')
    # print(*['*' for i in range(0, self.no_cols+2)])

  def uncover(self, row: int, col: int):
    # Check if the given coord contains bomb
    if self.game_board[row][col] == Field.BOMB_VALUE:
      self.game_board_uncovered[row][col] = Field.BOMB_STEPPED
      return Field.BOMB_STEPPED
    else:
      # Uncover the coord
      self.game_board_uncovered[row][col] = self.game_board[row][col]
      # loop through the neighbourhoods

      # Reinitialize kernel_range everytime
      kernel_size = 3
      kernel_range = self.get_kernel_range(row, col, kernel_size)
      kernel_checked = set(kernel_range)
      while (True):
        # check for bomb in neighbourhood of kernel
        if self.if_bomb_in_neighbourhood(kernel_range):
          # ###### Case uncover for the task that I missed
          # 
          # self.uncover_game_board(row, col, kernel_range)
          return 
        else:
          # uncover the mask 
          self.uncover_game_board(kernel_range)
          # increase the kernel size and update range accordingly
          # in a effiecient way
          kernel_size = kernel_size + 2
          # This is efficient as it does not repeat checking the same neighbourhoods again and again
          kernel_checked.update(kernel_range)
          kernel_range = set(self.get_kernel_range(row, col, kernel_size))-kernel_checked # set(kernel_range) 
        
  
  def get_game_board_value(self, row: int, col: int)-> int:
    """
    """
    try:
      return self.game_board[row][col]
    except IndexError:
      return 0

    
          
  def if_bomb_in_neighbourhood(self, kernel_range: List[Tuple])-> bool:
    convolution_value = 0
    for pos in kernel_range:
      convolution_value += 1*self.get_game_board_value(pos[Field.POSX], pos[Field.POSY])

    # convolution expoldes if the bomb is detected in the neighbourhood ;-)
    if convolution_value == Field.BOMB_VALUE:
      self.bombs_uncovered +=1
      return True
    else:
      return False

  def count_bomb_in_neighbourhood(self,row: int, col: int, kernel_range: List[Tuple])-> int:
    """
    Counts the no. of bombs in the neighbourhood
    """
    bomb_count = 0# self.bombs_uncovered
    for pos in kernel_range:
      if self.get_game_board_value(pos[Field.POSX], pos[Field.POSY]) == Field.BOMB_VALUE:
        try:
          self.game_board[row][col] += 1
          bomb_count += 1
        except IndexError:
          continue
          
    return bomb_count
  
  def uncover_game_board(self, kernel_range: List[Tuple]):
    """
    """
    for pos in kernel_range:
      try:
        self.game_board_uncovered[pos[Field.POSX]][pos[Field.POSY]] = self.game_board[pos[Field.POSX]][pos[Field.POSY]]
      except IndexError:
        continue
    
  def get_kernel_range(self, row: int, col: int, kernel_size: int)-> List[Tuple]:
    """
    helper function to generate kernel range
    """
    x = [k+row for k in range(-(kernel_size//2), kernel_size//2 +1) if k+row >= 0]
    y = [k+col for k in range(-(kernel_size//2), kernel_size//2 +1) if k+col >= 0]
    kernel_range = list(itertools.product(x,y))
    return kernel_range

"""# Test Cases"""

def add_test_cases()-> List[Dict]:
  tests = []

  # Test case 1
  test_case1 = {
      inputs:{
          no_rows:3,
          no_cols:3,
          no_bombs:1, 
          bomb_positions: [(0,0)],
          uncover_positions: [(2,2), (0,1), (1,0)]
      }
  }
  tests.append(test_case1)
  # Test case 2
  """
  test_case2 = {
      inputs:{
          no_rows:3,
          no_cols:3,
          no_bombs:1, 
          bomb_positions: [(0,0)],
          uncover_positions: [(0,0)]
      }
  }
  tests.append(test_case2)
  """
  # Test case 3
  test_case3 = {
      inputs:{
          no_rows:4,
          no_cols:4,
          no_bombs:2, 
          bomb_positions: [(0,0), (1,1)],
          uncover_positions: [(3,3)]
      }
  }
  tests.append(test_case3)

  # Test case 4
  test_case4 = {
      inputs:{
          no_rows:4,
          no_cols:4,
          no_bombs:2, 
          bomb_positions: [(0,0), (1,1)],
          uncover_positions: [(2,2), (3,3), (1,1)]
      }
  }
  tests.append(test_case4)
  # Test case 5
  test_case5 = {
      inputs:{
          no_rows:4,
          no_cols:4,
          no_bombs:1, 
          bomb_positions: [(0,0)],
          uncover_positions: [(3,3),(0,2), (3,3), (1,1)]
      }
  }
  tests.append(test_case5)
  # Test case 6
  test_case6 = {
      inputs:{
          no_rows:10,
          no_cols:10,
          no_bombs:5, 
          bomb_positions: [(0,0), (1, 2), (0,1),(2,0),(2, 3)],
          uncover_positions: [(8,8), (3,3),(0,0), (0,2), (3,3), (1,1), (9,0)]
      }
  }
  tests.append(test_case6)
  return tests

def execute_test_cases(tests: List[Dict]):
  for i, test in enumerate(tests, start=1):
    print(f'Test case: {i}')
    input = test[inputs]

    # creating board
    game = Game(input[no_rows], input[no_cols], input[no_bombs])

    # Adding bombs
    for pos in input[bomb_positions]:
      game.add_bombs(pos[0], pos[1])

    # Updating the bombs of the neighbourhood
    game.update_bombs()

    # Uncover
    for pos in input[uncover_positions]:
      print(f'sweep: {pos}')
      if game.uncover(pos[0], pos[1]) == Field.BOMB_STEPPED:
        print(f'***BOOM***')
        break
      game.print_board()
    game.print_board()
    print(f'***** Revealing board *****')
    game.print_board(game.game_board)
    # print(f'Board: {game.game_board}')
    # game.print_board()

"""# Main implementation"""

if __name__ == '__main__':
  tests = add_test_cases()
  execute_test_cases(tests)

